
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Lox</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Lox는 Go를 위한 렉서 및 파서 생성기입니다" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
  <link rel="stylesheet" href="./prism.css"/>
  <link rel="stylesheet" href="./css.css" />
  <link 
</head>
<body>
  <div class="sidebar">
    <h1><a href="./index.html">Lox</a></h1>
    <ul>
  <li>
    <a href="getting_started.html">시작하기</a>
      <ul>
  <li>
    <a href="#installing-lox">Lox 설치하기</a>
  </li>
  <li>
    <a href="#trying-an-example">예제 실행하기</a>
  </li>
  <li>
    <a href="#next-steps">다음 단계</a>
  </li>
      </ul>
  </li>
      <li><a href="./reference.html">레퍼런스</a>
        <ul>
  <li>
    <a href="lexer_reference.html">렉서 레퍼런스</a>
  </li>
  <li>
    <a href="parser_reference.html">파서 레퍼런스</a>
  </li>
  <li>
    <a href="go_reference.html">Go 레퍼런스</a>
  </li>
        </ul>
      </li>
      <li><a href="./advanced.html">고급</a>
        <ul>
  <li>
    <a href="parser_conflicts.html">파서 충돌</a>
  </li>
        </ul>
      </li>
    </ul>
  </div>

  <div class="article">
    <div class="sidebar-button">
      <a  href="javascript:void(0)" onclick="toggleSidebar()"></a>
    </div>
    <h1 id="getting-started">시작하기</h1>

<p>Lox는 Go 언어를 위한 파서/렉서 생성기입니다. 프로젝트의 문법과 Go 소스를 분석하는 <code>lox</code>
도구로 구성되어 있으며, Go로 의존성 없는 파서를 생성합니다.</p>

<h2 id="installing-lox">Lox 설치하기</h2>

<p>플랫폼에 맞는 <a href="https://github.com/dcaiafa/lox/releases/latest" target="_blank">최신</a> 버전의
<code>lox</code>를 다운로드하세요. 압축을 풀고 <code>lox</code> 바이너리를 <code>PATH</code>에 있는 디렉토리에
복사하세요.</p>

<p class="notice"><code>lox</code>가 Go 소스를 분석하기 때문에, 특히 Go 도구를 업그레이드할 때
자주 업데이트하는 것이 매우 중요합니다.</p>

<h2 id="trying-an-example">예제 실행하기</h2>

<p>Lox를 배우는 가장 좋은 방법은
<a href="https://github.com/dcaiafa/lox/tree/main/examples" target="_blank">예제</a>를 실행해보는 것입니다. 이 섹션에서는
<a href="https://github.com/dcaiafa/lox/tree/main/examples/calc" target="_blank">계산기</a>를
사용합니다.</p>

<p>먼저 터미널에서 <code>calc</code> 디렉토리로 이동한 후 <code>go run .</code>을 사용하여 예제를 실행해보세요.
<code>2 * (1+3)</code>과 같은 표현식을 입력하면 결과를 볼 수 있습니다.</p>

<p>다음으로, <code>pow(2,8) - 1</code>과 같은 것을 계산할 수 있도록 내장 함수를 지원하도록 프로젝트를
확장해봅시다. 함수 이름(<code>sqrt</code>, <code>pow</code> 등)과 일치할 식별자 토큰이 필요합니다.
또한 매개변수 구분자로 사용할 쉼표 토큰도 필요합니다.</p>

<p>편집기에서 <code>calc.lox</code>를 열고, <code>NUM</code> 정의 바로 다음인 <code>@lexer</code>
섹션 끝에 다음을 추가하세요:</p>

<pre><code class="language-lox">COMMA = ','
ID = [A-Za-z][A-Za-z0-9]*
</code></pre>

<p>이제 함수 호출을 위한 파서 규칙을 추가합니다. <code>@parser</code> 섹션 끝(파일 끝부분)에
다음을 추가하세요:</p>

<pre><code class="language-lox">func_call = ID '(' @list(expr, ',')? ')'
</code></pre>

<p><code>ID</code> <code>'('</code> <code>')'</code> 부분은 간단해 보일 것입니다. <code>@list(expr,
',')</code> 항은 <code>,</code>로 구분된 하나 이상의 <code>expr</code>과 일치합니다. <code>?</code> 한정자는
이를 선택사항으로 만들어 매개변수를 받지 않는 함수(예: <code>pi()</code>)를 가질 수 있게 합니다.
문법에서 토큰을 이름(예: <code>COMMA</code>) 또는 리터럴 값(예: <code>','</code>)으로 참조할 수 있음을
주목하세요. 후자가 보통 읽기 쉽지만, 토큰 정의가 단순한 리터럴일 때만 허용됩니다.</p>

<p>이제 <code>func_call</code>을 포함하도록 <code>expr</code>의 정의를 변경하세요:</p>

<pre><code class="language-lox">expr = expr '+' expr  @left(1)
     | expr '-' expr  @left(1)
     | expr '*' expr  @left(2)
     | expr '/' expr  @left(2)
     | expr '%' expr  @left(2)
     | expr '^' expr  @right(3)
     | '(' expr ')'
     | num
     | func_call
</code></pre>

<p>문법 변경이 완료되었습니다. Go 변경 사항으로 넘어가기 전에, <code>calc</code> 디렉토리에서
<code>lox .</code>를 실행하세요. 다음과 같은 오류가 표시될 것입니다:</p>

<pre><code> $ lox .
calc.lox:35:1: rule missing action method: func_call
Error: errors ocurred
</code></pre>

<p>Lox는 모든 규칙의 모든 프로덕션이 해당하는 액션을 가지기를 기대하기 때문에 이 오류가
발생했습니다.</p>

<p><code>func_call</code>을 위한 액션을 추가해봅시다. IDE에서 <code>parser.go</code>를 열고 파일 끝에
다음을 추가하세요:</p>

<pre><code class="language-go">func (p *calcParser) on_func_call(
	id Token, _ Token, args []float64, _ Token,
) float64 {
	name := string(id.Str)
	switch name {
	case &quot;pow&quot;:
		if len(args) != 2 {
			p.errLogger.Errorf(id.Pos, &quot;pow takes 2 arguments&quot;)
			return 0
		}
		return math.Pow(args[0], args[1])

	default:
		p.errLogger.Errorf(id.Pos, &quot;invalid function %v&quot;, name)
		return 0
	}
}
</code></pre>

<p>다시 <code>lox .</code>를 실행해보세요. 오류가 없어야 합니다. 그리고 프로젝트를 다시 실행하여
<code>pow(2, 8) - 1</code>과 같은 표현식의 결과를 얻을 수 있을 것입니다.</p>

<p><code>on_func_call</code>의 구현이 꽤 간단해 보이길 바랍니다. 하지만 메서드 시그니처에서
많은 마법이 일어나고 있습니다. Lox는 액션을 프로덕션과 매칭하기 위해 메서드의 이름과
매개변수의 개수 및 타입을 모두 사용합니다. 자세한 내용은 <a href="./go_reference.html#action-methods">액션 메서드</a>
문서를 확인하세요.</p>

<h2 id="next-steps">다음 단계</h2>

<ul>
<li><a href="./reference.html">레퍼런스</a> 문서를 확인하세요.</li>
<li>다른 <a href="https://github.com/dcaiafa/lox/tree/main/examples" target="_blank">예제들</a>을 탐색해보세요.</li>
<li>Lox는 자기 자신으로 구축되었습니다. Lox의
<a href="https://github.com/dcaiafa/lox/blob/main/internal/parser/parser.lox" target="_blank">파서</a>를 살펴보세요.</li>
</ul>

  </div>

  <script src="./scripts.js"></script>
  <script src="./prism.js"></script>
  <script src="./prism-lox.js"></script>
</body>
