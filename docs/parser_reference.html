
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Lox</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Lox는 Go를 위한 렉서 및 파서 생성기입니다" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
  <link rel="stylesheet" href="./prism.css"/>
  <link rel="stylesheet" href="./css.css" />
  <link 
</head>
<body>
  <div class="sidebar">
    <h1><a href="./index.html">Lox</a></h1>
    <ul>
  <li>
    <a href="getting_started.html">Getting Started</a>
  </li>
      <li><a href="./reference.html">Reference</a>
        <ul>
  <li>
    <a href="lexer_reference.html">Lexer Reference</a>
  </li>
  <li>
    <a href="parser_reference.html">Parser Reference</a>
      <ul>
  <li>
    <a href="#parser-section">Parser Section</a>
  </li>
  <li>
    <a href="#rules">Rules</a>
      <ul>
  <li>
    <a href="#line-continuation">Line Continuation</a>
  </li>
  <li>
    <a href="#start-rule">Start Rule</a>
  </li>
  <li>
    <a href="#empty-production">Empty Production</a>
  </li>
      </ul>
  </li>
  <li>
    <a href="#term-cardinality">Term Cardinality</a>
      <ul>
  <li>
    <a href="#optional">Optional (?)</a>
  </li>
  <li>
    <a href="#one-or-more">One or More (+)</a>
  </li>
  <li>
    <a href="#zero-or-more">Zero or More (*)</a>
  </li>
  <li>
    <a href="#list-list">List (@list)</a>
  </li>
  <li>
    <a href="#precedence-and-associativity">Precedence and Associativity</a>
      <ul>
  <li>
    <a href="#left-associativity-left">Left Associativity (@left)</a>
  </li>
  <li>
    <a href="#right-associativity-right">Right Associativity (@right)</a>
  </li>
      </ul>
  </li>
      </ul>
  </li>
      </ul>
  </li>
  <li>
    <a href="go_reference.html">Go Reference</a>
  </li>
        </ul>
      </li>
      <li><a href="./advanced.html">Advanced</a>
        <ul>
  <li>
    <a href="parser_conflicts.html">Parser Conflicts</a>
  </li>
        </ul>
      </li>
    </ul>
  </div>

  <div class="article">
    <div class="sidebar-button">
      <a  href="javascript:void(0)" onclick="toggleSidebar()"></a>
    </div>
    <h1 id="parser-reference">파서 레퍼런스</h1>

<p>파서의 목적은 문법에 부합하는 토큰 문자열을 인식하고,
선택적으로 이를 다른 것으로 변환하는 것입니다.</p>

<h2 id="parser-section">파서 섹션</h2>

<p>파서 선언은 <code>@parser</code> 키워드로 시작하는 파서 섹션에
포함됩니다.</p>

<pre><code class="language-lox">@parser

// 파서 선언
</code></pre>

<h2 id="rules">규칙</h2>

<p>파서 규칙은 파서의 기본 구성 요소입니다. 터미널(토큰)과 비터미널(다른 규칙)의
변환을 정의하며, 재귀적으로 다른 규칙 프로덕션의 항으로 참조될 수
있습니다. 파서 규칙 구문은
<a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form" target="_blank">확장 백커스-나우르 형식</a>
(EBNF)과 유사합니다.</p>

<p>Lox 규칙 구문 자체를 Lox로 간결하게 표현할 수 있습니다:</p>

<pre><code class="language-lox">rule      = '@start'? ID '=' @list(prod, '|') NL
prod      = term_card+ qualif?
          | '@empty'

term_card = term card?
term      = ID | LITERAL | '@error' | list
list      = '@list' '(' term ',' term ')'
card      = '*' | '*!' | '+' | '?'
qualif    = '@left' '(' NUM ')'
          | '@right' '(' NUM ')'
</code></pre>

<p>다음 예제 규칙을 자세히 살펴보겠습니다:</p>

<pre><code class="language-lox">prod = term_card+ qualif?
     | '@empty'

</code></pre>

<ul>
<li><code>prod</code>는 규칙의 이름입니다.</li>
<li><code>term_card+ qualif?</code>와 <code>'@empty'</code>는 규칙의 프로덕션입니다.</li>
<li><code>term_card+</code>와 <code>qualif?</code>는 첫 번째 프로덕션의 항입니다.</li>
<li><code>term_card</code>와 <code>qualif</code>는 다른 규칙을 참조합니다.</li>
<li><code>+</code>는 하나 이상의 <code>term_card</code>가 예상됨을 나타내는 카디널리티입니다.
마찬가지로 <code>?</code>는 0개 또는 1개의 <code>qualif</code>가 예상됨을 나타냅니다.</li>
<li><code>'@empty'</code>는 리터럴 형식으로 참조되는 토큰입니다.</li>
</ul>

<p><strong>참고사항:</strong></p>

<ul>
<li>규칙 이름은 유효한 <a href="https://go.dev/ref/spec#Identifiers" target="_blank">Go
식별자</a>여야 하며 다음 추가 제한사항이
있습니다:

<ul>
<li>밑줄(<code>_</code>)로 시작하면 <strong>안 됩니다</strong>.</li>
<li>연속된 밑줄을 포함하면 <strong>안 됩니다</strong>.</li>
</ul></li>
</ul>

<h3 id="line-continuation">줄 연속</h3>

<p>규칙은 줄 끝으로 종료됩니다. 줄 연속 백슬래시 <code>\</code>를 사용하여
규칙을 여러 줄로 나눌 수 있습니다. 수직 막대 <code>|</code>가 다음 줄의
첫 번째 토큰일 때는 백슬래시를 생략할 수 있습니다. 이 경우
줄 연속이 암시적입니다.</p>

<p>예를 들어:</p>

<pre><code class="language-lox">term = ID | \
       LITERAL | \
       '@error' | \ 
       list
</code></pre>

<p>다음과 동일합니다:</p>

<pre><code class="language-lox">term = ID
     | LITERAL
     | '@error'
     | list
</code></pre>

<p>후자 형식을 사용하는 것이 관용적이며, <code>|</code>에서 규칙을 나눌 수
없을 때만 <code>\</code>를 사용합니다.</p>

<h3 id="start-rule">시작 규칙</h3>

<p>하나의 규칙, 그리고 오직 하나의 규칙만이 <code>@start</code> 키워드를 사용하여
루트 또는 시작 규칙으로 표시되어야 합니다. 시작 규칙은 파서의 목표입니다.
파서가 시작 규칙을 리듀스하면 파싱이 성공적으로 완료됩니다.</p>

<p>예제:</p>

<pre><code class="language-lox">@start program = statement*
</code></pre>

<h3 id="empty-production">빈 프로덕션</h3>

<p>빈 문자열과 일치하는 프로덕션 - 형식 문법에서 종종 그리스 문자
엡실론(ε)으로 표현됨 - 은 항 대신 <code>@empty</code> 키워드를
사용해야 합니다.</p>

<p>예제:</p>

<pre><code class="language-lox">optional_number = NUMBER | @empty
</code></pre>

<p>이 예제에서 <code>optional_number</code> 규칙은 <code>NUMBER</code> 토큰과 일치하거나
아무것도 일치하지 않음(즉, 빈 문자열)으로 리듀스될 수 있습니다.</p>

<h2 id="term-cardinality">항 카디널리티</h2>

<p>항은 카디널리티 수정자로 주석을 달 수 있으며, 이는 항의 인스턴스가
몇 개 일치될 수 있는지를 결정합니다. 카디널리티는 규칙 내에서 선택적,
반복 또는 필수 패턴을 지정하는 데 사용됩니다.</p>

<h3 id="optional">선택적 (?)</h3>

<p><code>?</code>는 항이 선택적임을 나타냅니다.</p>

<p>예제:</p>

<pre><code class="language-lox">some_rule = some_term?

// Lox가 생성:
some_term? = some_term
           | @empty
</code></pre>

<h3 id="one-or-more">하나 이상 (+)</h3>

<p><code>+</code>는 항이 하나 이상 일치될 수 있음을 나타냅니다.</p>

<p>예제:</p>

<pre><code class="language-lox">some_rule = some_term+

// Lox가 생성:
some_term+ = some_term+ some_term
           | some_term
</code></pre>

<h3 id="zero-or-more">0개 이상 (*)</h3>

<p><code>*</code>는 항이 0개 이상 일치될 수 있음을 나타냅니다.</p>

<p>예제:</p>

<pre><code class="language-lox">some_rule = some_term*

// Lox가 생성:
some_term*  = some_term+?
some_term+? = some_term+
            | @empty
some_term+  = some_term+ some_term
            | some_term
</code></pre>

<h3 id="list-list">리스트 (@list)</h3>

<p><code>@list(elem, sep)</code>는 항이 <code>sep</code>로 구분되면서 <code>elem</code>을 하나 이상
일치시킬 것임을 나타냅니다.</p>

<p>예제:</p>

<pre><code class="language-lox">some_rule = @list(some_term, ',')

// Lox가 생성:
@list(some_term, ',') = @list(some_term, ',') ',' some_term
                      | some_term
</code></pre>

<p><code>@list</code>는 <code>?</code>로 추가 수식하여 0개 이상의 요소 리스트와
일치시킬 수 있습니다.</p>

<h3 id="precedence-and-associativity">우선순위와 결합성</h3>

<p>다음 문법은 모호합니다. 이를 분석하려고 시도하면
<code>grammar has conflicts</code> 오류로 실패합니다:</p>

<pre><code class="language-lox">expr = expr '+' expr
     | expr '*' expr
     | NUMBER
</code></pre>

<p>일반적인 설명은 <a href="./parser_conflicts.html">파서 충돌</a>을 참조하세요.</p>

<p>연산자 우선순위와 관련된 충돌은 우선순위와 결합성 수식자를
사용하여 해결할 수 있습니다:</p>

<pre><code class="language-lox">expr = expr '+' expr  @left(1)
     | expr '*' expr  @left(2)
     | NUMBER
</code></pre>

<p>문법의 <code>@left</code> 수식자는 <code>lox</code>에게 <code>expr '+' expr</code>와
<code>expr '*' expr</code> 사이의 충돌을 만났을 때 후자가 전자보다
우선순위를 가져야 한다고 알려줍니다.</p>

<p class="notice">Lox의 우선순위 수식자는 <strong>단일 규칙 내</strong>의 모호성을 해결하는 데
사용됩니다. 모호성이 여러 규칙에 걸쳐 있으면 우선순위 수식자는
효과가 없으며, 해결을 위해 문법 리팩토링이 필요할 것입니다.</p>

<p>연산자 우선순위의 충돌을 해결할 때는 연산자의 결합성도 고려하는 것이
중요합니다. 결합성은 괄호가 없을 때 동일한 우선순위 수준의 연산자가
어떻게 그룹화되는지를 결정합니다.</p>

<h4 id="left-associativity-left">좌결합성 (@left)</h4>

<p>덧셈과 뺄셈 같은 좌결합 연산자의 경우, 연산자의 여러 인스턴스가
연속으로 나타날 때 파서는 왼쪽부터 그룹화합니다.</p>

<p>예제:</p>

<pre><code class="language-lox">expr = expr '+' expr  @left(1)
     | NUMBER
</code></pre>

<p>입력 <code>1 + 2 + 3</code>이 주어지면 파서는 다음과 같이 처리합니다:</p>

<pre><code>(1 + 2) + 3
</code></pre>

<p>이는 <code>@left</code> 수식자 때문이며, 이는 파서가 다음을 고려하기 전에
첫 번째 <code>expr</code>을 리듀스하게 합니다.</p>

<h4 id="right-associativity-right">우결합성 (@right)</h4>

<p>거듭제곱이나 할당 같은 우결합 연산자의 경우, 파서는 오른쪽부터 표현식을 그룹화합니다.</p>

<p>예제:</p>

<pre><code class="language-lox">expr = expr '^' expr  @right(1)
     | NUMBER
</code></pre>

<p>입력 <code>2 ^ 3 ^ 4</code>의 경우, 파서는 다음과 같이 그룹화합니다:</p>

<pre><code>2 ^ (3 ^ 4)
</code></pre>

  </div>

  <script src="./scripts.js"></script>
  <script src="./prism.js"></script>
  <script src="./prism-lox.js"></script>
</body>
