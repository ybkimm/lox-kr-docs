
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Lox</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Lox는 Go를 위한 렉서 및 파서 생성기입니다" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
  <link rel="stylesheet" href="./prism.css"/>
  <link rel="stylesheet" href="./css.css" />
  <link 
</head>
<body>
  <div class="sidebar">
    <h1><a href="./index.html">Lox</a></h1>
    <ul>
  <li>
    <a href="getting_started.html">시작하기</a>
  </li>
      <li><a href="./reference.html">레퍼런스</a>
        <ul>
  <li>
    <a href="lexer_reference.html">렉서 레퍼런스</a>
  </li>
  <li>
    <a href="parser_reference.html">파서 레퍼런스</a>
  </li>
  <li>
    <a href="go_reference.html">Go 레퍼런스</a>
      <ul>
  <li>
    <a href="#token-type">토큰 타입</a>
  </li>
  <li>
    <a href="#parser-type">파서 타입</a>
      <ul>
  <li>
    <a href="#action-methods">액션 메서드</a>
  </li>
  <li>
    <a href="#onbounds">_onBounds</a>
  </li>
      </ul>
  </li>
  <li>
    <a href="#generated-code">생성된 코드</a>
      <ul>
  <li>
    <a href="#lox">lox</a>
  </li>
  <li>
    <a href="#lexer">_Lexer</a>
  </li>
      </ul>
  </li>
      </ul>
  </li>
        </ul>
      </li>
      <li><a href="./advanced.html">고급</a>
        <ul>
  <li>
    <a href="parser_conflicts.html">파서 충돌</a>
  </li>
        </ul>
      </li>
    </ul>
  </div>

  <div class="article">
    <div class="sidebar-button">
      <a  href="javascript:void(0)" onclick="toggleSidebar()"></a>
    </div>
    <h1 id="go-reference">Go 레퍼런스</h1>

<p>ANTLR과 유사하게(그리고 Bison/Yacc와 달리), Lox는 문법과 사용자가 작성한
코드를 분리합니다. ANTLR과 달리, Lox는 문법과 사용자가 작성한 코드를 모두
분석하여 파서가 어떻게 생성되어야 하는지 결정합니다. 프로덕션(문법/lox)을
액션(사용자 작성/Go)과 매칭하고 이러한 관계를 사용하여 액션 매개변수와
반환값의 타입을 검사합니다. 결과적으로 사용자가 작성한 Go 코드는 파서가
생성되기 전에 특정 요구사항을 충족해야 합니다.</p>

<p class="notice">항상 최신 Lox 릴리스를 사용하는 것이 중요합니다. 특히 Go 툴체인을
업데이트한 후에는 더욱 그렇습니다. <code>lox</code>가 이상하거나 설명할 수 없는
Go 관련 오류를 반환한다면, <code>lox</code> 버전이 너무 오래되었을 가능성이 높습니다.</p>

<p class="notice">Lox는 생성된 코드와 사용자가 작성한 Go 코드 간의 심볼 충돌을 방지하기 위해
관용적이지 않은 접두사를 사용합니다. 구체적으로 <code>on_</code> 접두사(아래 설명)와
단일 언더스코어 <code>_</code> 접두사(예: <code>_TokenToString</code>)를 예약합니다.
Lox는 향후 <code>_</code> 접두사를 사용하는 더 많은 심볼을 추가할 권리를 보유합니다.</p>

<h2 id="token-type">토큰 타입</h2>

<p>파서 패키지는 Lox가 토큰을 표현하는 데 사용할 <code>Token</code>이라는 타입을 정의해야
합니다. <code>Token</code>은 렉서가 반환하는 타입과 동일해야 합니다. 프로젝트에서
<a href="https://github.com/dcaiafa/loxlex/simplelexer" target="_blank">simplelexer</a>를 사용하는
경우(초보자에게 권장), <code>Token</code>은 simplelexer의 <code>Token</code> 타입에 대한 별칭이어야
합니다:</p>

<pre><code class="language-go">type Token = simplelexer.Token
</code></pre>

<h2 id="parser-type">파서 타입</h2>

<p>파서 패키지는 파서 타입도 정의해야 합니다. 이름은 중요하지 않지만,
lox 도구가 생성할 <code>lox</code> 타입을 임베드해야 합니다:</p>

<pre><code class="language-go">type myParser struct {
  lox

  // 다른 필드들.
}

</code></pre>

<p><code>lox</code>를 임베드하면 해당 타입이 파서 타입으로 표시됩니다. Lox는 이 타입에서
액션을 찾고, 이 타입에 메서드도 생성합니다.</p>

<h3 id="action-methods">액션 메서드</h3>

<p>각 문법 프로덕션은 파서가 해당 프로덕션을 리듀스할 때 실행할 대응하는 Go 액션
메서드를 가져야 합니다. 프로덕션 메서드는 <a href="#parser-type">파서 타입</a>에 정의되어야
합니다. 메서드 이름은 <code>on_&lt;rule&gt;</code> 또는 <code>on_&lt;rule&gt;__&lt;suffix&gt;</code> 패턴을 따라야
합니다. 여기서 <code>&lt;rule&gt;</code>은 프로덕션을 정의하는 규칙의 이름이고 <code>&lt;suffix&gt;</code>는
동일한 규칙에 대해 여러 액션 메서드를 허용하기 위한 선택적 문자열입니다.
<code>&lt;suffix&gt;</code>의 실제 값은 중요하지 않으며, Lox에 의해 무시됩니다.</p>

<p>액션 메서드는 단일 결과를 반환해야 합니다. 규칙에 두 개 이상의 액션 메서드가
있는 경우, 모두 동일한 타입을 반환해야 합니다. 각 프로덕션 항은 액션 매개변수와
대응되어야 합니다. 항이 참조하는 규칙이나 토큰의 Go 타입은 대응하는 매개변수
타입에 <a href="https://go.dev/ref/spec#Assignability" target="_blank">할당 가능</a>해야 합니다.</p>

<p>예를 들어:</p>

<pre><code class="language-lox">statement = ID '=' expr
          | 'call' ID

</code></pre>

<pre><code class="language-go">func (p *myParser) on_statement__assign(id Token, _ Token, e Expr) Statement {
    return &amp;AssignStat{id, e}
}

func (p *myParser) on_statement__call(_ Token, id Token) Statement {
    return &amp;CallStat{id}
}
</code></pre>

<p>메서드 <code>on_statement__assign</code>은 프로덕션 <code>statement = ID '=' expr</code>과
다음과 같은 이유로 매칭됩니다:</p>

<ul>
<li><code>on_statement</code>는 규칙 <code>statement</code>와 매칭됩니다 (접미사 <code>__assign</code>은
무시됨).</li>
<li><code>id Token</code>은 항 <code>ID</code>와 매칭됩니다 (모든 토큰은 <code>Token</code> 타입과 매칭).</li>
<li><code>_ Token</code>은 항 <code>=</code>와 매칭됩니다 (매개변수 이름은 중요하지 않고, 타입만
중요함).</li>
<li><code>e Expr</code>은 항 <code>expr</code>과 매칭됩니다 (액션이 <code>Expr</code>을 반환하는 규칙 <code>expr</code>이
있다고 가정).</li>
</ul>

<p>프로덕션은 단일 액션 메서드와 매칭되어야 합니다.</p>

<p>예를 들어:</p>

<pre><code class="language-lox">statement = 'ID' = 'expr'
</code></pre>

<pre><code class="language-go">func (p *myParser) on_statement__1(id Token, _ Token, e Expr) Statement {
    return &amp;AssignStat{id, e}
}
func (p *myParser) on_statement__2(id, _, e any) Statement {
    return &amp;AssignStat{id.(Token), e.(Expr)}
}
</code></pre>

<p>이 예제에서 <code>lox</code>는 <code>on_statement__1</code>과 <code>on_statement__2</code> 모두 하나의
<code>statement</code> 프로덕션에 대한 액션 메서드로 사용될 수 있기 때문에 오류를
생성합니다.</p>

<h3 id="onbounds">_onBounds</h3>

<p><a href="#parser-type">파서 타입</a>이 <code>_onBounds</code>라는 메서드를 정의하면, 생성된 파서는
모든 리듀스 아티팩트에 대해 시작 및 끝 토큰 형태로 어휘 경계를 정의하는 정보와
함께 이를 한 번 호출합니다. 예를 들어, 이는 AST에 소스 위치 정보를 저장하는 데
사용할 수 있습니다.</p>

<p><code>_onBounds</code>가 지정된 경우, 다음 시그니처를 가져야 합니다:</p>

<pre><code class="language-go">func (p *yourParser) _onBounds(r any, begin, end Token) {
    // ...
}
</code></pre>

<p>여기서 <code>r</code>은 리듀스 아티팩트이고, <code>begin</code>과 <code>end</code>는 경계 토큰입니다.</p>

<p class="notice"><code>_onBounds</code>를 정의한 후 파서를 재생성하기 위해 <code>lox</code>를 실행해야 합니다.
그렇지 않으면 호출되지 않습니다.</p>

<p>오류 로깅 목적으로 AST와 소스 위치 정보를 연결하는 데 <code>_onBounds</code>를 사용하는
방법의 예제는
<a href="https://github.com/dcaiafa/lox/blob/main/examples/bolox/parser.go" target="_blank">Bolox</a>를
확인하세요.</p>

<h2 id="generated-code">생성된 코드</h2>

<p>Lox가 생성한 파일은 다음 패턴을 따릅니다: <code>*.gen.go</code> (예:
<code>parser.gen.go</code>). 생성된 코드에는 파서, 렉서 상태 머신 및 기타 지원 타입과
함수가 포함됩니다. 이 섹션은 참조/사용할 수 있는 코드를 문서화합니다.</p>

<h3 id="lox">lox</h3>

<p>Lox는 파서를 실행하는 데 사용되는 데이터 구조를 포함하는 <code>lox</code> 타입을
생성합니다. 동일한 패키지에 이 타입을 임베드하는 <code>struct</code>를 정의해야 합니다.
이것은 Lox에게 이 <code>struct</code>가 파서임을 알려줍니다. Lox는 이 타입에 파서를
구현하는 메서드를 추가합니다.</p>

<h3 id="lexer">_Lexer</h3>

<p>Lox는 다음과 같이 <code>_Lexer</code> 인터페이스를 생성합니다:</p>

<pre><code class="language-go">type _Lexer interface {
	ReadToken() (Token, int)
}
</code></pre>

<p><code>_Lexer</code>는 파서가 요구하는 인터페이스를 정의합니다. 재미있는 사실: Lox는
실제 렉서를 생성하지 않고, 렉서를 위한 상태 머신을 생성합니다. <code>_Lexer</code>
구현을 제공하는 것은 사용자의 책임입니다.
<a href="https://github.com/dcaiafa/loxlex/tree/main/simplelexer" target="_blank">simplelexer</a>는
Lox에 포함된 예제에서 사용되는 렉서 구현이며, 대부분의 프로젝트에 충분합니다.
외부 의존성으로 사용하는 대신 프로젝트에 복사할 수 있을 정도로 작고 간단합니다.</p>

  </div>

  <script src="./scripts.js"></script>
  <script src="./prism.js"></script>
  <script src="./prism-lox.js"></script>
</body>
